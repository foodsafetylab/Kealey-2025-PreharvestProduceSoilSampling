---
title: "Data exploration"
execute:
  echo: false
  message: false
  warning: false
bibliography: references.bib
---


# Data exploration

```{r, include=FALSE}
# Load functions in "common_code.R"
# at some point this should be moved into bookdown
source("src/common_code.R", local = knitr::knit_global())
```

```{r, echo=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE, include = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())

options(stringsAsFactors = FALSE)
```

## Project Description

This project is focused on comparing Juno versus X9 sequencing instruments. 16S region was amplified and sequenced using the Fluigim platform. There is a total of 192 samples with two replicates for each instrument including control and standards. The factors are described below:


**SampleType:**

-  G
-  Neonic



**Instrument:**

-  X9
-  Juno


**Replicate:**

-  1
-  2


## Import and Preprocessing

### Create a phyloseq object

This only need to be done once, load file directly from next step once created.

-   `seqtab`: "data/Phyloseq/seqtab_final.md5.merged.RDS"

-   `taxtab`: "data/Phyloseq/tax_final.md5.merged.RDS"

-   `tree`: "data/Plain/Trees/rooted.merged.newick"

-   `refseq`: "data/Plain/Sequences/asvs.md5.nochim.merged.fna"

-   `metadata`: created based on the file/information PI provided

```{r}
taxa <- readRDS(file = "data/Phyloseq/tax_final.md5.merged.RDS")

asvs <- readRDS(file = "data/Phyloseq/seqtab_final.md5.merged.RDS")
rownames(asvs) <-sub(".merged.filtered.fastq.gz", "", rownames(asvs)) # trim row names to avoid later issues with physeq object 


seqraw <- Biostrings::readDNAStringSet("data/Plain/Sequences/asvs.md5.nochim.merged.fna", 
                                         format = 'fasta')
#Load tree
tree.tmp <- read.tree("data/Plain/Trees/rooted.merged.newick")

# Build phyloseq object 
physeq <- phyloseq(tax_table(taxa),otu_table(asvs, taxa_are_rows = FALSE),seqraw, tree.tmp)

#Rename taxonomy rankings
colnames(tax_table(physeq)) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")

```

### Import and adjust the metadata

We import the metadata created manually and convert variables to factors and make new variables combining our variables of interest. The first 15 lines of metadata is shown below:

```{r, show_col_types = FALSE}
# Load the metadata
#tmp <- read_xlsx("data/metadata.xlsx", sheet = 1)
tmp <- read.csv("data/metadata.csv")
# colnames(tmp)[1] <- "SampleID"
#head(tmp)

# Convert to factor -----
tmp$Instrument <- factor(tmp$Instrument, levels = unique(tmp$Instrument))
tmp$SampleType <- factor(tmp$SampleType, levels = unique(tmp$SampleType))
tmp$Replicate <- factor(tmp$Replicate, levels = unique(tmp$Replicate))

# Create a group from Trt * Day -----
tmp$group <- paste(tmp$SampleType,tmp$Instrument, sep = "_")
tmp$group <- factor(tmp$group, levels = unique(tmp$group))
#tmp$group2 <- gsub("NegativeControl_NC", "NegativeControl", tmp$group)

# Create Label from Trt * Day * Dog -----
tmp$Label <- paste(tmp$group, tmp$Replicate, sep = "_")
tmp$Label <- factor(tmp$Label, levels = unique(tmp$Label))
#ncol(tmp)
#View(tmp)

# Move column positions -----
#write.csv(tmp, "../data/metadata_edited.csv", row.names = F)

knitr::kable(head(tmp, n = 15), show_col_types = FALSE)
```

### DADA2 results

We also read in QC to check the quality of data. DADA2 [@callahan2016dada2] implements a novel algorithm that models the errors introduced during amplicon sequencing, and uses that error model to infer the true sample composition. Excerpt from [here](https://bioconductor.org/packages/devel/bioc/vignettes/dada2/inst/doc/dada2-intro.html). 

<!-- Samples with `input:` \< 1000, `seqtab.merged.nochim` \< 1000 or `PctKept` \< 40 are highlighted in the table below.  -->
```{r}
track <- read_delim("data/Plain/QC/all.readtracking.merged.txt",show_col_types = FALSE)
track$PctKept <- round(track$seqtab.merged.nochim/track$input*100,2)

```

#### Top 20 samples

```{r proces results}
knitr::kable(track[c(1:20),-2])  %>%
  kable_styling() 
#%>%
 # column_spec(2, background = ifelse(track$input < 1000, "darkorange", "none")) %>%
#  column_spec(7, background = ifelse(track$seqtab.merged.nochim < 1000, "salmon2", "none"))
#%>%
  #column_spec(8, background = ifelse(track$PctKept < 40, "brown2", "none"))
```

#### Samples that have < 1000 final reads

```{r proces results2}
df <- track[,-2]
df <- df[which(track$seqtab.merged.nochim < 1000),]
#nrow(df)

knitr::kable(df)  %>%
  kable_styling() 
#%>%
 # column_spec(2, background = ifelse(track$input < 1000, "darkorange", "none")) %>%
#  column_spec(7, background = ifelse(track$seqtab.merged.nochim < 1000, "salmon2", "none"))
#%>%
  #column_spec(8, background = ifelse(track$PctKept < 40, "brown2", "none"))
```


#### DADA2 results plotted for each ID

Now, we plot the QC results from DADA2 read fate at each step in stacked barplot both by percentage and number per sample.

```{r results="asis", show_col_types = FALSE, fig.width=10}
###### CREATE  PERCENTAGE PLOT  ###### 

#Do star read fates
ReadFate <- dplyr::select(track, input:seqtab.merged.nochim)
ReadFate$Label <- factor(track$SampleID, levels = track$SampleID)
rownames(ReadFate) <- track$SampleID # adjust rownames

# Convert to long format
df <- tidyr::pivot_longer(ReadFate, 
                           input:seqtab.merged.nochim, 
                           names_to = "Fate", 
                           values_to = "pct")
# Convert Fate column to factor
df$Fate <- factor(df$Fate, levels = unique(df$Fate), 
                   ordered = TRUE)

# ##### Percentages of reads
# x11(width = 12)
ggplot(df, aes(x = Label, y = pct, fill = forcats::fct_rev(Fate))) +
  geom_bar(position="fill", stat="identity") +
  scale_fill_manual("Fate",values = dittoSeq::dittoColors()[1:6]  )+
  theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 10)) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, face = "bold", size = 10)) +
   theme(axis.title.x = element_text(face = "bold", size = 14)) +
  theme(axis.title.y = element_text(face = "bold", size = 14)) +
  theme(legend.text=element_text(size=11))+
  theme(legend.title=element_text(size=12))+
  theme(legend.position="bottom")+
  theme(plot.title =element_text(face = "bold", size = 14))+
   ggtitle("Percentage of reads in DADA2 sample inference") +
  ylab("Percent of reads") +
  scale_y_continuous(labels = scales::percent) 
#ggsave("results/DADA2_StackedPct_bySample.jpeg")


###### CREATE READ NUMBER PLOT  ###### 

# # Numbers of reads
ggplot(df, aes(x = Label, y = pct / 1e6, fill = forcats::fct_rev(Fate))) +
  geom_bar(position="stack", stat="identity") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold", size = 10)) +
  theme(axis.text.y = element_text(angle = 0, hjust = 1, face = "bold", size = 10)) +
   theme(axis.title.x = element_text(face = "bold", size = 14)) +
  theme(axis.title.y = element_text(face = "bold", size = 14)) +
  theme(legend.text=element_text(size=11))+
  theme(legend.title=element_text(size=12))+
  theme(legend.position="bottom")+
  theme(plot.title =element_text(face = "bold", size = 14))+
  ggtitle("Number of reads in DADA2 sample inference") +
  ylab("Millions of reads") +
  scale_fill_manual("Fate",values = dittoSeq::dittoColors()[1:6]  )
#ggsave("results/DADA2_StackedNum_bySample.jpeg")

```

### Combine metadata and QC info.

```{r}
tmp2 <- sample_data(right_join(tmp, track, by="SampleID"))

sample_names(tmp2) <- tmp2$SampleID
sample_data(physeq) <- tmp2
rownames(otu_table(physeq)) <- rownames(tmp2)
```

We then combine all metadata together (initital metadata + QC information) for analysis. Below you see a summary of the initial phyloseq object using QIIME2 taxonomy assignments. We have `r nrow(tax_table(physeq))` taxa across `r ncol(tax_table(physeq))` ranks and `r nrow(sample_data(physeq))` samples. Note that the Phyloseq package uses the term "OTU" to describe features, but since we used dada2 to create the feature table, we actually have ASVs (Amplicon Sequence Variants), which are essentially 100% OTUs. So anywhere you see the term OTU, remember that these are actually ASVs.

```{r}
print(physeq)

```

Selected columns from the combined metadata and QC is shown below:

```{r results="asis"}
sample_data(physeq)[,c(3:7)] %>% as("data.frame") %>% head %>% knitr::kable()

sample_data(physeq)[,c(9:ncol(sample_data(physeq)))] %>% as("data.frame") %>% head %>% knitr::kable()
```

```{r}
## Save file
saveRDS(physeq, 'results/physeq.raw.RDS')
#tax_table(subset_taxa(physeq, Genus=="Lepidosauria"))
```
